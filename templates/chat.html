{% extends "_base.html" %}

{% block content %}
<button data-drawer-target="chat-sidebar" data-drawer-toggle="chat-sidebar" aria-controls="chat-sidebar" type="button" class="text-heading bg-transparent box-border border border-transparent hover:bg-neutral-secondary-medium focus:ring-4 focus:ring-neutral-tertiary font-medium leading-5 rounded-base ms-3 mt-3 text-sm p-2 focus:outline-none inline-flex sm:hidden">
  <span class="sr-only">Open sidebar</span>
  <svg class="w-6 h-6" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
    <path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5 7h14M5 12h14M5 17h10"/>
  </svg>
</button>

<aside id="chat-sidebar" class="fixed top-16 left-0 z-30 w-64 h-[calc(100vh-5rem)] transition-transform -translate-x-full sm:translate-x-0 border-e border-t border-default" aria-label="Chat sidebar">
  <div class="h-full px-3 py-4 overflow-y-auto bg-neutral-primary-soft">
    {% if chat_key_models %}
    <div class="mb-4">
      
      <select
        id="model-select"
        class="w-full rounded-base border border-default-medium bg-neutral-primary text-heading text-sm focus:ring-2 focus:ring-brand focus:border-brand focus:outline-none p-2 disabled:opacity-50 disabled:cursor-not-allowed"
        aria-label="Preferred chat model"
        {% if has_streaming %}disabled{% endif %}
      >
        {% for m in chat_key_models %}
        <option value="{{ m.value }}" {% if m.value == chat_default_model %}selected{% endif %}>{{ m.label }}</option>
        {% endfor %}
      </select>
    </div>
    {% endif %}
    <ul class="space-y-2 font-medium">
      <li>
        <a href="{% url 'chat' %}" class="flex items-center px-2 py-1.5 text-body rounded-base hover:bg-neutral-tertiary hover:text-fg-brand group">
          <svg class="w-5 h-5 transition duration-75 group-hover:text-fg-brand" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v14m-7-7h14"/>
          </svg>
          <span class="ms-3">New chat</span>
        </a>
      </li>
    </ul>
    <ul class="space-y-2 font-medium border-t border-default pt-4 mt-4">
      <li class="px-2 py-1.5 text-xs text-body uppercase tracking-wider">Your chats</li>
      {% for t in threads %}
        <li>
          <a
            href="{% url 'chat_thread' thread_id=t.id %}"
            class="flex items-center px-2 py-1.5 text-body rounded-base hover:bg-neutral-tertiary hover:text-fg-brand group {% if active_thread.id == t.id %}bg-neutral-tertiary text-heading{% endif %}"
            data-thread-id="{{ t.id }}"
          >
            <span class="truncate">{{ t.title|default:"Untitled chat" }}</span>
          </a>
        </li>
      {% empty %}
        <li class="px-2 py-1.5 text-sm text-body">No chats yet.</li>
      {% endfor %}
    </ul>
  </div>
</aside>

<div class="sm:ml-64 min-h-[calc(100vh-5rem)] flex flex-col">
  <main class="max-w-3xl mx-auto w-full px-4 py-6 flex flex-col flex-1">
    <div class="flex-1 flex flex-col">
    <div class="mb-4 text-center">
      {% if has_older and older_cursor %}
        <a href="{% url 'chat_thread' thread_id=active_thread.id %}?before={{ older_cursor }}" class="text-sm text-fg-brand font-medium hover:underline">Load more messages</a>
      {% elif has_older %}
        <a href="#" class="text-sm text-fg-brand font-medium hover:underline">Load more messages</a>
      {% endif %}
    </div>

    <div class="flex-1 space-y-6 pb-4 overflow-y-auto" id="messages-scroll-container">
      <div id="chat-messages" class="space-y-6">
        {% for m in messages %}
          {% if m.role == "user" %}
            <div class="flex justify-end" data-message-id="{{ m.id }}" data-role="{{ m.role }}" data-status="{{ m.status }}">
              <div class="flex items-start gap-2.5 flex-row-reverse">
                <span class="inline-flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-100 dark:bg-blue-900/60 text-sm font-semibold text-blue-900 dark:text-blue-100">
                  {{ user.email|first|upper }}
                </span>
                <div class="flex flex-col w-full max-w-[320px] leading-1.5 p-4 bg-blue-50 dark:bg-gray-700 rounded-e-base rounded-es-base">
                  <div class="flex items-center space-x-1.5 rtl:space-x-reverse">
                    <span class="text-sm font-semibold text-heading">You</span>
                    <span class="text-sm text-body">{{ m.created_at|date:"H:i" }}</span>
                  </div>
                  <div class="text-sm py-2.5 text-body markdown-content">{{ m.content }}</div>
                </div>
              </div>
            </div>
          {% else %}
            <div class="flex items-start gap-2.5" data-message-id="{{ m.id }}" data-role="{{ m.role }}" data-status="{{ m.status }}">
              <div class="flex flex-col w-full">
                <div class="flex items-center space-x-2">
                  <span class="text-sm font-semibold text-heading">Assistant</span>
                  <span class="text-sm text-body">{{ m.created_at|date:"H:i" }}</span>
                </div>
                <div class="text-sm text-body mt-2 markdown-content">{{ m.content }}</div>
              </div>
            </div>
          {% endif %}
        {% empty %}
          {% if not active_thread %}
            {# Placeholder message for new chat - display only, never saved #}
            <div class="flex items-start gap-2.5" data-placeholder="true">
              <div class="flex flex-col w-full">
                <div class="flex items-center space-x-2">
                  <span class="text-sm font-semibold text-heading">Assistant</span>
                  <span class="text-sm text-body" id="placeholder-time"></span>
                </div>
                <p class="text-sm text-body mt-2">What's on the agenda today?</p>
              </div>
            </div>
          {% else %}
            <p class="text-sm text-body">No messages yet.</p>
          {% endif %}
        {% endfor %}
      </div>
    </div>
  </div>

  <form class="flex gap-2 pt-4" action="#" method="post" id="chat-form" {% if active_thread %}data-thread-id="{{ active_thread.id }}"{% endif %}>
    {% csrf_token %}
    {% if active_thread %}
    <input type="hidden" name="thread_id" value="{{ active_thread.id }}">
    {% endif %}
    <div class="flex-1 flex items-end gap-2">
      <div id="connection-status" class="flex items-center gap-1.5 shrink-0 mb-2.5" title="Connection status">
        <!-- Spinner when connecting -->
        <div id="connection-spinner" class="hidden" role="status">
          <svg aria-hidden="true" class="w-4 h-4 text-neutral-quaternary animate-spin fill-brand" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
            <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/>
          </svg>
          <span class="sr-only">Connecting...</span>
        </div>
        <!-- Status indicator dot when connected/disconnected -->
        <span id="connection-indicator" class="flex w-2.5 h-2.5 rounded-full border-2 border-buffer bg-gray-400 dark:bg-gray-500"></span>
        <span id="connection-text" class="text-xs text-body">Connecting...</span>
      </div>
      <textarea
        name="message"
        placeholder="Type your message..."
        id="message-input"
        rows="1"
        class="flex-1 rounded-base border border-default-medium bg-neutral-primary text-heading text-sm focus:ring-2 focus:ring-brand focus:border-brand focus:outline-none p-2.5 disabled:opacity-50 disabled:cursor-not-allowed resize-none overflow-hidden"
        style="min-height: 2.5rem; max-height: 7.5rem;"
        {% if has_streaming %}disabled{% endif %}
      ></textarea>
    </div>
    <button
      type="submit"
      id="send-button"
      class="text-white bg-brand hover:bg-brand-strong focus:ring-4 focus:ring-brand-medium font-medium rounded-base text-sm px-4 py-2.5 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed self-end"
      style="height: 2.5rem;"
      {% if has_streaming %}disabled{% endif %}
    >
      Send
    </button>
  </form>
  
  <!-- Markdown rendering libraries -->
  <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
  
  <!-- Markdown styling - scoped to chat messages only -->
  <style>
    /* Headers */
    #chat-messages .markdown-content h1,
    .markdown-content h1 {
      font-size: 1.875rem; /* 30px */
      font-weight: 700;
      margin-top: 1.5rem;
      margin-bottom: 1rem;
      line-height: 1.2;
    }
    #chat-messages .markdown-content h2,
    .markdown-content h2 {
      font-size: 1.5rem; /* 24px */
      font-weight: 600;
      margin-top: 1.25rem;
      margin-bottom: 0.75rem;
      line-height: 1.3;
    }
    #chat-messages .markdown-content h3,
    .markdown-content h3 {
      font-size: 1.25rem; /* 20px */
      font-weight: 600;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      line-height: 1.4;
    }
    #chat-messages .markdown-content h4,
    .markdown-content h4 {
      font-size: 1.125rem; /* 18px */
      font-weight: 600;
      margin-top: 0.875rem;
      margin-bottom: 0.5rem;
      line-height: 1.4;
    }
    #chat-messages .markdown-content h5,
    .markdown-content h5 {
      font-size: 1rem; /* 16px */
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
      line-height: 1.5;
    }
    #chat-messages .markdown-content h6,
    .markdown-content h6 {
      font-size: 0.875rem; /* 14px */
      font-weight: 600;
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
      line-height: 1.5;
    }
    
    /* Paragraphs */
    #chat-messages .markdown-content p,
    .markdown-content p {
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      line-height: 1.6;
    }
    #chat-messages .markdown-content p:first-child,
    .markdown-content p:first-child {
      margin-top: 0;
    }
    #chat-messages .markdown-content p:last-child,
    .markdown-content p:last-child {
      margin-bottom: 0;
    }
    
    /* Lists */
    #chat-messages .markdown-content ul,
    #chat-messages .markdown-content ol,
    .markdown-content ul,
    .markdown-content ol {
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      padding-left: 1.5rem;
    }
    #chat-messages .markdown-content ul,
    .markdown-content ul {
      list-style-type: disc;
    }
    #chat-messages .markdown-content ol,
    .markdown-content ol {
      list-style-type: decimal;
    }
    #chat-messages .markdown-content li,
    .markdown-content li {
      margin-top: 0.25rem;
      margin-bottom: 0.25rem;
      line-height: 1.6;
    }
    #chat-messages .markdown-content ul ul,
    #chat-messages .markdown-content ol ol,
    #chat-messages .markdown-content ul ol,
    #chat-messages .markdown-content ol ul,
    .markdown-content ul ul,
    .markdown-content ol ol,
    .markdown-content ul ol,
    .markdown-content ol ul {
      margin-top: 0.25rem;
      margin-bottom: 0.25rem;
    }
    #chat-messages .markdown-content ul ul,
    .markdown-content ul ul {
      list-style-type: circle;
    }
    #chat-messages .markdown-content ul ul ul,
    .markdown-content ul ul ul {
      list-style-type: square;
    }
    
    /* Code blocks */
    #chat-messages .markdown-content pre,
    .markdown-content pre {
      background-color: rgb(243 244 246); /* gray-100 */
      border: 1px solid rgb(229 231 235); /* gray-200 */
      border-radius: 0.375rem; /* rounded-md */
      padding: 1rem;
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      overflow-x: auto;
      font-size: 0.875rem; /* 14px */
      line-height: 1.5;
    }
    #chat-messages .markdown-content pre code,
    .markdown-content pre code {
      background-color: transparent;
      border: none;
      padding: 0;
      font-size: inherit;
      color: inherit;
    }
    
    /* Inline code */
    #chat-messages .markdown-content code,
    .markdown-content code {
      background-color: rgb(243 244 246); /* gray-100 */
      border: 1px solid rgb(229 231 235); /* gray-200 */
      border-radius: 0.25rem; /* rounded */
      padding: 0.125rem 0.375rem;
      font-size: 0.875em;
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
    }
    #chat-messages .markdown-content pre code,
    .markdown-content pre code {
      background-color: transparent;
      border: none;
      padding: 0;
    }
    
    /* Blockquotes */
    #chat-messages .markdown-content blockquote,
    .markdown-content blockquote {
      border-left: 4px solid rgb(156 163 175); /* gray-400 */
      padding-left: 1rem;
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      color: rgb(107 114 128); /* gray-500 */
      font-style: italic;
    }
    #chat-messages .markdown-content blockquote p,
    .markdown-content blockquote p {
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
    #chat-messages .markdown-content blockquote p:first-child,
    .markdown-content blockquote p:first-child {
      margin-top: 0;
    }
    #chat-messages .markdown-content blockquote p:last-child,
    .markdown-content blockquote p:last-child {
      margin-bottom: 0;
    }
    #chat-messages .markdown-content blockquote blockquote,
    .markdown-content blockquote blockquote {
      margin-left: 1rem;
      border-left-color: rgb(209 213 219); /* gray-300 */
    }
    
    /* Links - scoped to markdown content within chat messages only */
    #chat-messages .markdown-content a {
      color: rgb(59 130 246); /* blue-500 */
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    #chat-messages .markdown-content a:hover {
      color: rgb(37 99 235); /* blue-600 */
    }
    
    /* Horizontal rules - make more visible */
    #chat-messages .markdown-content hr,
    .markdown-content hr {
      border: none;
      border-top: 2px solid rgb(209 213 219); /* gray-300 */
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      height: 0;
      display: block;
    }
    
    /* Emphasis */
    #chat-messages .markdown-content em,
    .markdown-content em {
      font-style: italic;
    }
    #chat-messages .markdown-content strong,
    .markdown-content strong {
      font-weight: 700;
    }
    #chat-messages .markdown-content u,
    .markdown-content u {
      text-decoration: underline;
    }
    
    /* Strikethrough */
    #chat-messages .markdown-content del,
    #chat-messages .markdown-content s,
    .markdown-content del,
    .markdown-content s {
      text-decoration: line-through;
      text-decoration-color: rgb(107 114 128); /* gray-500 */
    }
    
    /* Tables */
    #chat-messages .markdown-content table,
    .markdown-content table {
      border-collapse: collapse;
      margin-top: 0.75rem;
      margin-bottom: 0.75rem;
      width: 100%;
      border: 1px solid rgb(229 231 235); /* gray-200 */
    }
    #chat-messages .markdown-content th,
    #chat-messages .markdown-content td,
    .markdown-content th,
    .markdown-content td {
      border: 1px solid rgb(229 231 235); /* gray-200 */
      padding: 0.5rem;
      text-align: left;
    }
    #chat-messages .markdown-content th,
    .markdown-content th {
      background-color: rgb(243 244 246); /* gray-100 */
      font-weight: 600;
    }

    /* Dark mode: markdown content */
    .dark #chat-messages .markdown-content pre,
    .dark .markdown-content pre {
      background-color: rgb(55 65 81); /* gray-700 */
      border-color: rgb(75 85 99); /* gray-600 */
    }
    .dark #chat-messages .markdown-content code,
    .dark .markdown-content code {
      background-color: rgb(55 65 81);
      border-color: rgb(75 85 99);
    }
    .dark #chat-messages .markdown-content blockquote,
    .dark .markdown-content blockquote {
      border-left-color: rgb(107 114 128);
      color: rgb(209 213 219);
    }
    .dark #chat-messages .markdown-content blockquote blockquote,
    .dark .markdown-content blockquote blockquote {
      border-left-color: rgb(156 163 175);
    }
    .dark #chat-messages .markdown-content a {
      color: rgb(96 165 250);
    }
    .dark #chat-messages .markdown-content a:hover {
      color: rgb(147 197 253);
    }
    .dark #chat-messages .markdown-content hr,
    .dark .markdown-content hr {
      border-top-color: rgb(75 85 99);
    }
    .dark #chat-messages .markdown-content del,
    .dark #chat-messages .markdown-content s,
    .dark .markdown-content del,
    .dark .markdown-content s {
      text-decoration-color: rgb(156 163 175);
    }
    .dark #chat-messages .markdown-content table,
    .dark .markdown-content table {
      border-color: rgb(75 85 99);
    }
    .dark #chat-messages .markdown-content th,
    .dark #chat-messages .markdown-content td,
    .dark .markdown-content th,
    .dark .markdown-content td {
      border-color: rgb(75 85 99);
    }
    .dark #chat-messages .markdown-content th,
    .dark .markdown-content th {
      background-color: rgb(55 65 81);
    }
  </style>
  
  <script>
    (function () {
      // Markdown rendering utilities
      function renderMarkdown(text) {
        if (!text) return "";
        try {
          // Replace emoji shortcodes before parsing markdown
          // Common emoji shortcodes
          const emojiMap = {
            ':sparkles:': '‚ú®',
            ':tada:': 'üéâ',
            ':smile:': 'üòÑ',
            ':heart:': '‚ù§Ô∏è',
            ':thumbsup:': 'üëç',
            ':thumbsdown:': 'üëé',
            ':fire:': 'üî•',
            ':rocket:': 'üöÄ',
            ':star:': '‚≠ê',
            ':check:': '‚úÖ',
            ':x:': '‚ùå',
            ':warning:': '‚ö†Ô∏è',
            ':bulb:': 'üí°',
            ':muscle:': 'üí™',
            ':clap:': 'üëè',
            ':eyes:': 'üëÄ',
            ':thinking:': 'ü§î',
            ':party:': 'üéâ',
            ':confetti:': 'üéä',
            ':trophy:': 'üèÜ',
            ':zap:': '‚ö°',
            ':boom:': 'üí•',
            ':100:': 'üíØ',
            ':ok_hand:': 'üëå',
            ':raised_hands:': 'üôå',
            ':pray:': 'üôè',
            ':coffee:': '‚òï',
            ':pizza:': 'üçï',
            ':cake:': 'üéÇ',
            ':gift:': 'üéÅ',
            ':balloon:': 'üéà',
          };
          
          // Replace emoji shortcodes with actual emojis
          let processedText = text;
          for (const [shortcode, emoji] of Object.entries(emojiMap)) {
            processedText = processedText.replace(new RegExp(shortcode.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), emoji);
          }
          
          // Parse markdown to HTML
          const html = marked.parse(processedText);
          // Sanitize HTML to prevent XSS
          return DOMPurify.sanitize(html, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 's', 'del', 'code', 'pre', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'a', 'hr', 'table', 'thead', 'tbody', 'tr', 'th', 'td'],
            ALLOWED_ATTR: ['href', 'title', 'target']
          });
        } catch (e) {
          console.error("Markdown parsing error:", e);
          // Fallback to plain text with HTML escaping
          return escapeHtml(text).replace(/\r\n/g, "<br>").replace(/\n/g, "<br>").replace(/\r/g, "<br>");
        }
      }
      
      function hasCompleteMarkdownBlock(text) {
        if (!text) return false;
        
        // Check for complete code blocks (```...```)
        const codeBlockMatches = text.match(/```/g);
        if (codeBlockMatches && codeBlockMatches.length >= 2) {
          // Check if last code block is closed
          const lastOpen = text.lastIndexOf('```');
          const afterLastOpen = text.substring(lastOpen + 3);
          if (afterLastOpen.includes('```')) {
            return true;
          }
        }
        
        // Check for complete list items (ends with newline after content)
        if (text.match(/^[\s]*[-*+]\s+.+\n$/m)) {
          return true;
        }
        
        // Check for complete paragraphs (double newline)
        if (text.match(/\n\n/)) {
          return true;
        }
        
        // Check for complete headers (# ... followed by newline)
        if (text.match(/^#{1,6}\s+.+\n$/m)) {
          return true;
        }
        
        return false;
      }
      
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }
      
      const form = document.getElementById("chat-form");
      if (!form) return;

      const input = form.querySelector('textarea[name="message"]');
      const button = form.querySelector('button[type="submit"]');
      const modelSelect = document.getElementById("model-select");
      const messagesContainer = document.getElementById("chat-messages");
      
      // Save preferred model when user changes the dropdown (user setting)
      if (modelSelect) {
        modelSelect.addEventListener("change", function() {
          const model = this.value;
          if (!model) return;
          const csrfInput = form.querySelector('input[name="csrfmiddlewaretoken"]');
          const csrf = csrfInput ? csrfInput.value : "";
          fetch("{% url 'chat_preferred_model_update' %}", {
            method: "POST",
            headers: {
              "X-CSRFToken": csrf,
              "X-Requested-With": "XMLHttpRequest",
              "Content-Type": "application/x-www-form-urlencoded",
            },
            body: "model=" + encodeURIComponent(model),
          }).catch(function(err) { console.error("Failed to save preferred model:", err); });
        });
      }
      
      // Render markdown for all server-rendered messages on page load
      // Only process elements within the chat messages container to avoid affecting sidebar
      function renderServerRenderedMarkdown() {
        const markdownElements = messagesContainer ? messagesContainer.querySelectorAll('.markdown-content') : document.querySelectorAll('#chat-messages .markdown-content');
        markdownElements.forEach(function(el) {
          const text = el.textContent || el.innerText;
          if (text) {
            el.innerHTML = renderMarkdown(text);
          }
        });
      }
      
      // Render markdown on page load (after DOM is ready)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', renderServerRenderedMarkdown);
      } else {
        renderServerRenderedMarkdown();
      }
      
      // Auto-resize textarea
      function autoResizeTextarea(textarea) {
        // Reset height to auto to get the correct scrollHeight
        textarea.style.height = 'auto';
        // Calculate new height (min 2.5rem, max 7.5rem)
        const minHeight = 40; // 2.5rem = 40px
        const maxHeight = 120; // 7.5rem = 120px (about 5 lines)
        const newHeight = Math.min(Math.max(textarea.scrollHeight, minHeight), maxHeight);
        const oldHeight = parseInt(textarea.style.height) || minHeight;
        textarea.style.height = newHeight + 'px';
        
        // If textarea grew, scroll page down to keep it visible
        if (newHeight > oldHeight) {
          // Use requestAnimationFrame to ensure DOM has updated
          requestAnimationFrame(function() {
            window.scrollTo({
              top: document.body.scrollHeight,
              behavior: 'smooth'
            });
          });
        }
      }
      
      // Handle Shift+Enter for newlines, Enter for submit
      if (input) {
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && !e.shiftKey) {
            // Enter without Shift: submit form
            e.preventDefault();
            if (!input.disabled && !locked) {
              form.dispatchEvent(new Event('submit'));
            }
          }
          // Shift+Enter: allow default behavior (newline)
        });
        
        // Auto-resize on input
        input.addEventListener('input', function() {
          autoResizeTextarea(input);
        });
        
        // Initial resize
        autoResizeTextarea(input);
      }
      
      // Track active thread ID (mutable for thread switching)
      // Read from URL path (e.g., /chat/uuid/) or fall back to form data attribute
      function getThreadIdFromUrl() {
        const pathParts = window.location.pathname.split('/').filter(p => p);
        // Check if path matches /chat/<uuid>/
        if (pathParts.length >= 2 && pathParts[0] === 'chat') {
          const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
          if (uuidPattern.test(pathParts[1])) {
            return pathParts[1];
          }
        }
        return null;
      }
      
      function getChatUrl(threadId) {
        // Return URL for chat thread: /chat/<uuid>/
        if (threadId) {
          return `/chat/${threadId}/`;
        }
        return '/chat/';
      }
      
      let activeThreadId = getThreadIdFromUrl() || form.dataset.threadId || null;

      // If no thread ID, we're in "new chat" mode - don't connect WebSocket yet
      // WebSocket will be connected after first message creates a thread

      // WebSocket connection management
      let ws = null;
      let reconnectTimeout = null;
      let reconnectAttempts = 0;
      const maxReconnectAttempts = 5;
      const reconnectDelay = 1000; // Start with 1s, will back off
      const STREAM_TIMEOUT_MS = 300000; // 300s stream timeout
      let streamingTimeout = null;

      // Track current streaming assistant message element
      let currentStreamingMessageId = null;
      let currentStreamingElement = null;
      let currentStreamingAccumulatedContent = ""; // Track accumulated raw content (may contain JSON)
      let currentStreamingDisplayContent = ""; // Track extracted display content (message only)

      function getWebSocketUrl(threadId) {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const host = window.location.host;
        return `${protocol}//${host}/ws/chat/${threadId}/`;
      }

      function connect(threadId) {
        // Use provided threadId or fall back to activeThreadId
        threadId = threadId || activeThreadId;
        if (!threadId) {
          console.warn("No thread ID available for WebSocket connection");
          return;
        }

        // If already connected to this thread, don't reconnect
        if (ws && ws.readyState === WebSocket.OPEN && activeThreadId === threadId) {
          return;
        }

        // Disconnect existing connection if switching threads
        if (ws && ws.readyState !== WebSocket.CLOSED) {
          ws.close(1000, "Switching threads");
        }

        activeThreadId = threadId;
        updateFormThreadId(threadId);

        try {
          // Show connecting state
          updateConnectionStatus(false, true);
          
          ws = new WebSocket(getWebSocketUrl(threadId));

          ws.onopen = function () {
            console.log("WebSocket connected");
            reconnectAttempts = 0;
            updateConnectionStatus(true, false);
            // Send initial pong to establish heartbeat
            ws.send(JSON.stringify({
              event_type: "pong",
              timestamp: Date.now(),
            }));
          };

          ws.onmessage = function (event) {
            const data = JSON.parse(event.data);
            handleWebSocketEvent(data);
          };

          ws.onerror = function (error) {
            console.error("WebSocket error:", error);
            updateConnectionStatus(false, false);
          };

          ws.onclose = function (event) {
            console.log("WebSocket closed", event.code, event.reason);
            updateConnectionStatus(false, false);

            // If we were in the middle of streaming, mark it as an error.
            if (currentStreamingElement) {
              const contentEl = currentStreamingElement.querySelector(".message-content");
              if (contentEl) {
                contentEl.innerHTML += "<br><br>[Connection lost]";
              }
              currentStreamingElement.setAttribute("data-status", "error");
              currentStreamingElement = null;
              currentStreamingMessageId = null;
              currentStreamingAccumulatedContent = ""; // Reset accumulated content
              currentStreamingDisplayContent = ""; // Reset display content
            }

            // Clear any pending timeout (form will be disabled by updateConnectionStatus)
            clearStreamingTimeout();

            // Attempt reconnection if not a normal closure
            if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts) {
              const delay = reconnectDelay * Math.pow(2, reconnectAttempts);
              reconnectAttempts++;
              console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts})...`);
              reconnectTimeout = setTimeout(connect, delay);
            }
          };
        } catch (error) {
          console.error("Failed to create WebSocket:", error);
          updateConnectionStatus(false, false);
        }
      }

      function disconnect() {
        if (reconnectTimeout) {
          clearTimeout(reconnectTimeout);
          reconnectTimeout = null;
        }
        if (ws) {
          ws.close(1000, "Disconnecting");
          ws = null;
        }
        reconnectAttempts = 0;
        updateConnectionStatus(false, false);
      }

      function startStreamingTimeout() {
        clearStreamingTimeout();
        streamingTimeout = setTimeout(function () {
          console.warn("Streaming timed out after", STREAM_TIMEOUT_MS, "ms");
          if (currentStreamingElement) {
            const contentEl = currentStreamingElement.querySelector(".message-content");
            if (contentEl) {
              contentEl.innerHTML += "<br><br>[Timed out]";
            }
            currentStreamingElement.setAttribute("data-status", "error");
            currentStreamingElement = null;
            currentStreamingMessageId = null;
            currentStreamingAccumulatedContent = ""; // Reset accumulated content
            currentStreamingDisplayContent = ""; // Reset display content
          }
          // Re-enable form (only if connected)
          if (ws && ws.readyState === WebSocket.OPEN) {
            if (input) input.disabled = false;
            if (button) button.disabled = false;
          }
        }, STREAM_TIMEOUT_MS);
      }

      function clearStreamingTimeout() {
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
          streamingTimeout = null;
        }
      }

      function updateFormThreadId(threadId) {
        // Update form's thread_id hidden input and data attribute
        const threadIdInput = form.querySelector('input[name="thread_id"]');
        if (threadId) {
          if (threadIdInput) {
            threadIdInput.value = threadId;
          } else {
            // Create hidden input if it doesn't exist
            const hiddenInput = document.createElement("input");
            hiddenInput.type = "hidden";
            hiddenInput.name = "thread_id";
            hiddenInput.value = threadId;
            form.appendChild(hiddenInput);
          }
          form.dataset.threadId = threadId;
        } else {
          // Remove thread_id input if threadId is null
          if (threadIdInput) {
            threadIdInput.remove();
          }
          delete form.dataset.threadId;
        }
      }

      function loadMessages(threadId, callback) {
        // Load messages for a thread via AJAX
        const url = `/chat/api/threads/${threadId}/messages/`;
        fetch(url, {
          method: "GET",
          headers: {
            "X-Requested-With": "XMLHttpRequest",
          },
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          // Clear existing messages (including any placeholder)
          messagesContainer.innerHTML = "";
          
          // Render messages
          const userEmail = "{{ user.email|first|upper }}";
          data.messages.forEach(function(msg) {
            const messageEl = createMessageElement(msg, userEmail);
            messagesContainer.appendChild(messageEl);
          });
          
          // If no messages, show placeholder only if no thread (new chat)
          if (data.messages.length === 0 && !activeThreadId) {
            const now = new Date();
            const timeStr = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");
            const placeholderEl = document.createElement("div");
            placeholderEl.className = "flex items-start gap-2.5";
            placeholderEl.setAttribute("data-placeholder", "true");
            placeholderEl.innerHTML = `
              <div class="flex flex-col w-full">
                <div class="flex items-center space-x-2">
                  <span class="text-sm font-semibold text-heading">Assistant</span>
                  <span class="text-sm text-body">${timeStr}</span>
                </div>
                <p class="text-sm text-body mt-2">What's on the agenda today?</p>
              </div>
            `;
            messagesContainer.appendChild(placeholderEl);
          }
          
          // Scroll to bottom
          scrollToBottom();
          
          if (callback) callback(data);
        })
        .catch(function(error) {
          console.error("Failed to load messages:", error);
          // On error, reload the page to get messages from server
          window.location.href = `/chat/?thread=${threadId}`;
        });
      }

      function createMessageElement(msg, userEmail) {
        const div = document.createElement("div");
        const date = new Date(msg.created_at);
        const timeStr = date.getHours().toString().padStart(2, "0") + ":" + date.getMinutes().toString().padStart(2, "0");
        
        if (msg.role === "user") {
          div.className = "flex justify-end";
          div.setAttribute("data-message-id", msg.id);
          div.setAttribute("data-role", msg.role);
          div.setAttribute("data-status", msg.status);
          div.innerHTML = `
            <div class="flex items-start gap-2.5 flex-row-reverse">
              <span class="inline-flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-200 dark:bg-blue-900/60 text-sm font-semibold text-blue-900 dark:text-blue-100">
                ${userEmail}
              </span>
              <div class="flex flex-col w-full max-w-[320px] leading-1.5 p-4 bg-blue-50 dark:bg-gray-700 rounded-e-base rounded-es-base">
                <div class="flex items-center space-x-1.5 rtl:space-x-reverse">
                  <span class="text-sm font-semibold text-heading">You</span>
                  <span class="text-sm text-body">${timeStr}</span>
                </div>
                <div class="text-sm py-2.5 text-body markdown-content">${renderMarkdown(msg.content)}</div>
              </div>
            </div>
          `;
        } else {
          div.className = "flex items-start gap-2.5";
          div.setAttribute("data-message-id", msg.id);
          div.setAttribute("data-role", msg.role);
          div.setAttribute("data-status", msg.status);
          div.innerHTML = `
            <div class="flex flex-col w-full">
              <div class="flex items-center space-x-2">
                <span class="text-sm font-semibold text-heading">Assistant</span>
                <span class="text-sm text-body">${timeStr}</span>
              </div>
              <div class="text-sm text-body mt-2 message-content markdown-content">${renderMarkdown(msg.content)}</div>
            </div>
          `;
        }
        
        return div;
      }

      function updateSidebarActiveState(threadId) {
        // Update sidebar active state
        const sidebarLinks = document.querySelectorAll('[data-thread-id]');
        sidebarLinks.forEach(function(link) {
          const linkThreadId = link.dataset.threadId;
          const isActive = threadId && linkThreadId === threadId;
          
          // Update classes
          if (isActive) {
            link.classList.add("bg-neutral-tertiary", "text-heading");
            link.classList.remove("text-body");
          } else {
            link.classList.remove("bg-neutral-tertiary", "text-heading");
            link.classList.add("text-body");
          }
        });
      }

      function moveThreadToTop(threadId) {
        // Move the thread to the top of the sidebar list (below "Your chats" header)
        if (!threadId) return;
        
        const sidebarLink = document.querySelector(`[data-thread-id="${threadId}"]`);
        if (!sidebarLink) return;
        
        const listItem = sidebarLink.closest("li");
        if (!listItem) return;
        
        const threadsList = document.querySelector("#chat-sidebar ul.space-y-2.border-t");
        if (!threadsList) return;
        
        // Find the first thread item (has data-thread-id attribute on child link)
        const headerItem = threadsList.firstElementChild;
        let firstThreadItem = null;
        for (let i = 0; i < threadsList.children.length; i++) {
          const child = threadsList.children[i];
          if (child.querySelector('[data-thread-id]')) {
            firstThreadItem = child;
            break;
          }
        }
        
        // If this is already the first thread item, no need to move
        if (listItem === firstThreadItem) return;
        
        // Insert after the header (which is firstElementChild), before the first thread item
        if (firstThreadItem) {
          threadsList.insertBefore(listItem, firstThreadItem);
        } else {
          // No other threads, insert after header
          threadsList.insertBefore(listItem, headerItem.nextSibling);
        }
      }

      function switchThread(newThreadId) {
        if (!newThreadId || newThreadId === activeThreadId) {
          return; // No change needed
        }

        console.log(`Switching from thread ${activeThreadId} to ${newThreadId}`);
        
        // Disconnect old connection
        disconnect();
        
        // Clear streaming state
        currentStreamingMessageId = null;
        currentStreamingElement = null;
        currentStreamingAccumulatedContent = ""; // Reset accumulated content
        currentStreamingDisplayContent = ""; // Reset display content
        
        // Update active thread ID
        activeThreadId = newThreadId;
        updateFormThreadId(newThreadId);
        updateSidebarActiveState(newThreadId);
        
        // Update URL without page reload (for better UX)
        const newUrl = getChatUrl(newThreadId);
        window.history.pushState({ threadId: newThreadId }, "", newUrl);
        
        // Load messages for the new thread
        loadMessages(newThreadId, function() {
          // Connect to new thread after messages are loaded
          connect(newThreadId);
        });
      }

      // Fix accessibility issue: ensure aria-hidden is removed when sidebar links receive focus
      function setupSidebarAccessibility() {
        const sidebar = document.getElementById("chat-sidebar");
        if (!sidebar) return;
        
        // Listen for focus events on sidebar links
        const sidebarLinks = sidebar.querySelectorAll('a');
        sidebarLinks.forEach(function(link) {
          link.addEventListener('focus', function() {
            // If sidebar has aria-hidden, remove it when a link gets focus
            if (sidebar.getAttribute('aria-hidden') === 'true') {
              sidebar.removeAttribute('aria-hidden');
            }
          });
        });
        
        // Also listen for drawer toggle events to properly manage aria-hidden
        // Flowbite drawer sets aria-hidden when hidden, but we need to ensure
        // it's removed if focus moves to sidebar content
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'aria-hidden') {
              const isHidden = sidebar.getAttribute('aria-hidden') === 'true';
              // If sidebar is being hidden, blur any focused elements inside
              if (isHidden) {
                const focusedElement = sidebar.querySelector(':focus');
                if (focusedElement) {
                  focusedElement.blur();
                }
              }
            }
          });
        });
        
        observer.observe(sidebar, {
          attributes: true,
          attributeFilter: ['aria-hidden']
        });
      }
      
      // Initialize sidebar accessibility fixes
      setupSidebarAccessibility();

      function updateConnectionStatus(connected, isConnecting) {
        const indicator = document.getElementById("connection-indicator");
        const spinner = document.getElementById("connection-spinner");
        const text = document.getElementById("connection-text");
        const input = document.getElementById("message-input");
        const button = document.getElementById("send-button");
        
        if (!indicator || !text || !input || !button) return;
        
        // Ensure form never gets unwanted background classes
        // Remove any bg-neutral-tertiary or text-heading classes that might have been added
        if (form) {
          form.classList.remove("bg-neutral-tertiary", "text-heading");
          // Ensure form only has the intended classes
          const intendedClasses = ["flex", "gap-2", "pt-4"];
          form.className = intendedClasses.join(" ");
        }
        
        // Show spinner when connecting, hide status dot
        if (isConnecting) {
          if (spinner) spinner.classList.remove("hidden");
          if (indicator) indicator.classList.add("hidden");
          text.textContent = "Connecting...";
          text.className = "text-xs text-body";
          // Disable form when connecting/disconnected
          input.disabled = true;
          button.disabled = true;
          if (modelSelect) modelSelect.disabled = true;
        } else if (connected) {
          // Hide spinner, show green status dot (no text when connected)
          if (spinner) spinner.classList.add("hidden");
          if (indicator) {
            indicator.classList.remove("hidden");
            indicator.className = "flex w-2.5 h-2.5 rounded-full border-2 border-buffer bg-success";
          }
          text.textContent = "";
          text.className = "text-xs text-body";
          // Enable form when connected (unless streaming)
          if (!currentStreamingElement) {
            input.disabled = false;
            button.disabled = false;
            if (modelSelect) modelSelect.disabled = false;
          }
        } else {
          // Disconnected: hide spinner, show red status dot
          if (spinner) spinner.classList.add("hidden");
          if (indicator) {
            indicator.classList.remove("hidden");
            indicator.className = "flex w-2.5 h-2.5 rounded-full border-2 border-buffer bg-danger";
          }
          if (reconnectAttempts > 0 && reconnectAttempts < maxReconnectAttempts) {
            text.textContent = `Reconnecting (${reconnectAttempts}/${maxReconnectAttempts})`;
            text.className = "text-xs text-body";
          } else {
            text.textContent = "Disconnected";
            text.className = "text-xs text-body text-danger";
          }
          // Disable form when disconnected
          input.disabled = true;
          button.disabled = true;
          if (modelSelect) modelSelect.disabled = true;
        }
      }

      function handleWebSocketEvent(data) {
        const eventType = data.event_type;

        // Handle heartbeat ping/pong
        if (eventType === "ping") {
          // Respond to server ping with pong
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              event_type: "pong",
              timestamp: data.timestamp || Date.now(),
            }));
          }
          return;
        }

        if (eventType === "pong_ack") {
          // Server acknowledged our pong (optional, just for confirmation)
          return;
        }

        if (eventType === "response.output_text.delta") {
          // Remove placeholder if it exists
          const placeholder = messagesContainer.querySelector('[data-placeholder="true"]');
          if (placeholder) {
            placeholder.remove();
          }
          
          // Append delta to current streaming assistant message
          const delta = data.delta || "";
          if (!currentStreamingElement) {
            // Create new assistant message element
            currentStreamingMessageId = "assistant-" + Date.now();
            currentStreamingElement = createAssistantMessageElement(currentStreamingMessageId);
            messagesContainer.appendChild(currentStreamingElement);
            scrollToBottom();

            // Start timeout tracking for this stream
            startStreamingTimeout();
            // Reset accumulated content for new stream
            currentStreamingAccumulatedContent = "";
            currentStreamingDisplayContent = "";
          }

          // Backend now sends plain text deltas (JSON extraction happens server-side)
          // Accumulate content and render markdown when complete blocks are detected
          const contentEl = currentStreamingElement.querySelector(".message-content");
          if (contentEl && delta) {
            // Accumulate raw text content
            currentStreamingAccumulatedContent += delta;
            
            // Check if we have a complete markdown block
            if (hasCompleteMarkdownBlock(currentStreamingAccumulatedContent)) {
              // Re-parse entire accumulated content as markdown
              contentEl.innerHTML = renderMarkdown(currentStreamingAccumulatedContent);
            } else {
              // Not a complete block yet - show as plain text with escaped HTML
              // This prevents broken markdown from showing during streaming
              const escapedDelta = escapeHtml(delta);
              const deltaWithBreaks = escapedDelta.replace(/\r\n/g, "<br>").replace(/\n/g, "<br>").replace(/\r/g, "<br>");
              contentEl.innerHTML += deltaWithBreaks;
            }
            scrollToBottom();
          }
        } else if (eventType === "final") {
          // Mark current streaming message as final
          if (currentStreamingElement) {
            // Final render of accumulated content as markdown
            const contentEl = currentStreamingElement.querySelector(".message-content");
            if (contentEl && currentStreamingAccumulatedContent) {
              contentEl.innerHTML = renderMarkdown(currentStreamingAccumulatedContent);
            }
            
            currentStreamingElement.setAttribute("data-status", "final");
            currentStreamingElement = null;
            currentStreamingMessageId = null;
            currentStreamingAccumulatedContent = ""; // Reset accumulated content
            currentStreamingDisplayContent = ""; // Reset display content

            // Re-enable form (only if connected)
            clearStreamingTimeout();
            if (ws && ws.readyState === WebSocket.OPEN) {
              if (input) input.disabled = false;
              if (button) button.disabled = false;
              if (modelSelect) modelSelect.disabled = false;
              if (input) input.focus();
            }
          }
          
          // Move active thread to top of sidebar (message completed, thread updated)
          if (activeThreadId) {
            moveThreadToTop(activeThreadId);
          }
        } else if (eventType === "thread.title.updated") {
          // Update thread title in sidebar
          const newTitle = data.title || "";
          if (newTitle && activeThreadId) {
            // Find the sidebar link for this thread and update its text
            let sidebarLink = document.querySelector(`[data-thread-id="${activeThreadId}"]`);
            
            // If thread doesn't exist in sidebar yet (newly created), add it
            if (!sidebarLink) {
              const threadsList = document.querySelector("#chat-sidebar ul.space-y-2.border-t");
              if (threadsList) {
                const listItem = document.createElement("li");
                // This thread is active (we're updating its title)
                listItem.innerHTML = `
                  <a
                    href="${getChatUrl(activeThreadId)}"
                    class="flex items-center px-2 py-1.5 text-body rounded-base hover:bg-neutral-tertiary hover:text-fg-brand group bg-neutral-tertiary text-heading"
                    data-thread-id="${activeThreadId}"
                  >
                    <span class="truncate">${escapeHtml(newTitle)}</span>
                  </a>
                `;
                // Insert after header (firstElementChild), before any existing threads
                const headerItem = threadsList.firstElementChild;
                const firstThreadItem = Array.from(threadsList.children).find(child => child.querySelector('[data-thread-id]'));
                if (firstThreadItem) {
                  threadsList.insertBefore(listItem, firstThreadItem);
                } else {
                  threadsList.insertBefore(listItem, headerItem.nextSibling);
                }
                sidebarLink = listItem.querySelector(`[data-thread-id="${activeThreadId}"]`);
                
                // Add click handler for the new link
                if (sidebarLink) {
                  sidebarLink.addEventListener("click", function(e) {
                    e.preventDefault();
                    switchThread(activeThreadId);
                  });
                }
              }
            }
            
            // Update the title text
            if (sidebarLink) {
              const titleSpan = sidebarLink.querySelector("span.ms-3");
              if (titleSpan) {
                titleSpan.textContent = newTitle;
              }
            }
          }
        } else if (eventType === "response.error") {
          // Handle error
          console.error("Stream error:", data);
          if (currentStreamingElement) {
            const contentEl = currentStreamingElement.querySelector(".message-content");
            if (contentEl) {
              const errorMsg = escapeHtml(data.error || "Unknown error");
              contentEl.innerHTML += "<br><br>[Error: " + errorMsg + "]";
            }
            currentStreamingElement.setAttribute("data-status", "error");
            currentStreamingElement = null;
            currentStreamingMessageId = null;
            currentStreamingAccumulatedContent = ""; // Reset accumulated content
            currentStreamingDisplayContent = ""; // Reset display content
          }

          // Re-enable form (only if connected)
          clearStreamingTimeout();
          if (ws && ws.readyState === WebSocket.OPEN) {
            if (input) input.disabled = false;
            if (button) button.disabled = false;
            if (modelSelect) modelSelect.disabled = false;
          }
        }
      }

      function createAssistantMessageElement(messageId) {
        const now = new Date();
        const timeStr = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");

        const div = document.createElement("div");
        div.className = "flex items-start gap-2.5";
        div.setAttribute("data-message-id", messageId);
        div.setAttribute("data-role", "assistant");
        div.setAttribute("data-status", "streaming");

        div.innerHTML = `
          <div class="flex flex-col w-full">
            <div class="flex items-center space-x-2">
              <span class="text-sm font-semibold text-heading">Assistant</span>
              <span class="text-sm text-body">${timeStr}</span>
            </div>
            <div class="text-sm text-body mt-2 message-content markdown-content"></div>
          </div>
        `;

        return div;
      }

      function scrollToBottom() {
        // Use requestAnimationFrame to ensure DOM has updated before scrolling
        requestAnimationFrame(function() {
          // Scroll the window to bottom (the container itself isn't scrollable)
          window.scrollTo({
            top: document.body.scrollHeight,
            behavior: 'auto'
          });
        });
      }

      // Form submission: HTTP POST (Option A) + WebSocket for streaming
      let locked = false;
      form.addEventListener("submit", function (e) {
        e.preventDefault();

        if (locked) return;

        const messageText = (input.value || "").trim();
        if (!messageText) return;

        // Create user message element immediately
        const userMessageId = "user-" + Date.now();
        const now = new Date();
        const timeStr = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");
        const userEmail = "{{ user.email|first|upper }}";

        const userDiv = document.createElement("div");
        userDiv.className = "flex justify-end";
        userDiv.setAttribute("data-message-id", userMessageId);
        userDiv.setAttribute("data-role", "user");
        userDiv.setAttribute("data-status", "final");

        userDiv.innerHTML = `
          <div class="flex items-start gap-2.5 flex-row-reverse">
            <span class="inline-flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-blue-200 dark:bg-blue-900/60 text-sm font-semibold text-blue-900 dark:text-blue-100">
              ${userEmail}
            </span>
            <div class="flex flex-col w-full max-w-[320px] leading-1.5 p-4 bg-blue-50 dark:bg-gray-700 rounded-e-base rounded-es-base">
              <div class="flex items-center space-x-1.5 rtl:space-x-reverse">
                <span class="text-sm font-semibold text-heading">You</span>
                <span class="text-sm text-body">${timeStr}</span>
              </div>
              <p class="text-sm py-2.5 text-body">${escapeHtml(messageText)}</p>
            </div>
          </div>
        `;

        // Remove placeholder if it exists
        const placeholder = messagesContainer.querySelector('[data-placeholder="true"]');
        if (placeholder) {
          placeholder.remove();
        }
        
        messagesContainer.appendChild(userDiv);
        
        // Scroll window to bottom immediately and with delays
        const scrollWindowToBottom = function() {
          window.scrollTo({
            top: document.body.scrollHeight,
            behavior: 'auto'
          });
        };
        
        // Try immediately
        scrollWindowToBottom();
        
        // Try after next frame and with delays
        requestAnimationFrame(function() {
          scrollWindowToBottom();
          setTimeout(scrollWindowToBottom, 10);
          setTimeout(scrollWindowToBottom, 50);
          setTimeout(scrollWindowToBottom, 100);
        });

        // Clear input and disable form
        input.value = "";
        autoResizeTextarea(input); // Reset height to minimum
        input.disabled = true;
        button.disabled = true;
        if (modelSelect) modelSelect.disabled = true;
        locked = true;
        
        // Reset streaming state for new message
        currentStreamingElement = null;
        currentStreamingMessageId = null;
        currentStreamingAccumulatedContent = "";
        currentStreamingDisplayContent = "";

        // Send via HTTP POST; backend will trigger Channels group_send to start streaming.
        // Use current URL path (will be /chat/ or /chat/<uuid>/)
        const url = form.getAttribute("action") || window.location.pathname;
        const formData = new FormData(form);
        formData.set("message", messageText);
        // Send current dropdown model so the message uses it even if save is still in flight (avoids one-message lag)
        if (modelSelect && modelSelect.value) formData.set("model", modelSelect.value);

        // If no active thread, we need to connect WebSocket first (to a temporary group)
        // then send POST, then switch to the actual thread group
        // For now, let's send POST and handle the response
        const postPromise = fetch(url, {
          method: "POST",
          body: formData,
          headers: {
            "X-Requested-With": "XMLHttpRequest",
          },
        })
        .then(function(response) {
          // If a new thread was created, update URL and connect WebSocket
          if (response.status === 201) {
            return response.json().then(function(data) {
              const newThreadId = data.thread_id;
              if (newThreadId && !activeThreadId) {
                // Update active thread ID
                activeThreadId = newThreadId;
                updateFormThreadId(newThreadId);
                
                // Update URL to include thread ID
                const newUrl = getChatUrl(newThreadId);
                window.history.pushState({ threadId: newThreadId }, "", newUrl);
                
                // Add thread to sidebar immediately (with "New chat" placeholder)
                // Title will be updated when thread.title.updated event arrives
                const threadsList = document.querySelector("#chat-sidebar ul.space-y-2.border-t");
                if (threadsList) {
                  // Remove "No chats yet" message if it exists
                  const noChatsMsg = threadsList.querySelector("li:not([data-thread-id])");
                  if (noChatsMsg && noChatsMsg.textContent.includes("No chats yet")) {
                    noChatsMsg.remove();
                  }
                  
                  const listItem = document.createElement("li");
                  listItem.innerHTML = `
                    <a
                      href="${getChatUrl(newThreadId)}"
                      class="flex items-center px-2 py-1.5 text-body rounded-base hover:bg-neutral-tertiary hover:text-fg-brand group bg-neutral-tertiary text-heading"
                      data-thread-id="${newThreadId}"
                    >
                      <span class="truncate">New chat</span>
                    </a>
                  `;
                  // Insert after header (firstElementChild), before any existing threads
                  const headerItem = threadsList.firstElementChild;
                  const firstThreadItem = Array.from(threadsList.children).find(child => child.querySelector('[data-thread-id]'));
                  if (firstThreadItem) {
                    threadsList.insertBefore(listItem, firstThreadItem);
                  } else {
                    threadsList.insertBefore(listItem, headerItem.nextSibling);
                  }
                  
                  // Add click handler
                  const sidebarLink = listItem.querySelector(`[data-thread-id="${newThreadId}"]`);
                  if (sidebarLink) {
                    sidebarLink.addEventListener("click", function(e) {
                      e.preventDefault();
                      switchThread(newThreadId);
                    });
                  }
                  
                  // Update sidebar active state
                  updateSidebarActiveState(newThreadId);
                }
                
                // Show connection status and connect WebSocket
                const connectionStatus = document.getElementById("connection-status");
                if (connectionStatus) connectionStatus.style.display = "flex";
                
                // Connect WebSocket - this will join the group and receive any pending events
                connect(newThreadId);
              }
              return newThreadId;
            });
          } else if (response.status === 200 && activeThreadId) {
            // Existing thread - message sent successfully, move thread to top
            moveThreadToTop(activeThreadId);
          }
          return null;
        })
        .catch(function (err) {
          console.error("Failed to POST message:", err);
          return null;
        });
        
        // Store the promise so we can wait for it if needed
        // The WebSocket connection will handle receiving the event

        // Re-enable after 1 second (throttle)
        setTimeout(function () {
          locked = false;
          // Form will be re-enabled when streaming completes (in handleWebSocketEvent)
        }, 1000);
      });

      // Initialize form - enable if no thread (new chat), disable if thread exists (wait for WebSocket)
      if (activeThreadId) {
        // We have a thread - disable form until WebSocket connects
        if (input) input.disabled = true;
        if (button) button.disabled = true;
        if (modelSelect) modelSelect.disabled = true;
        // Connect when page loads (messages are already rendered from server)
        connect(activeThreadId);
      } else {
        // No thread - new chat mode, form should be enabled
        // Explicitly enable form elements (remove any disabled attribute)
        if (input) {
          input.disabled = false;
          input.removeAttribute("disabled");
        }
        if (button) {
          button.disabled = false;
          button.removeAttribute("disabled");
        }
        if (modelSelect) {
          modelSelect.disabled = false;
          modelSelect.removeAttribute("disabled");
        }
        // Hide connection status for new chat
        const connectionStatus = document.getElementById("connection-status");
        if (connectionStatus) connectionStatus.style.display = "none";
        
        // Set timestamp for placeholder message
        const placeholderTime = document.getElementById("placeholder-time");
        if (placeholderTime) {
          const now = new Date();
          const timeStr = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");
          placeholderTime.textContent = timeStr;
        }
      }

      // Scroll to bottom on initial load
      setTimeout(scrollToBottom, 100);

      // Disconnect when leaving page
      window.addEventListener("beforeunload", function () {
        disconnect();
      });

      // Handle browser back/forward navigation (popstate)
      window.addEventListener("popstate", function (event) {
        const threadIdFromUrl = getThreadIdFromUrl();
        if (threadIdFromUrl && threadIdFromUrl !== activeThreadId) {
          switchThread(threadIdFromUrl);
        } else if (!threadIdFromUrl && activeThreadId) {
          // Navigated back to /chat/ - show empty chat with placeholder
          disconnect();
          activeThreadId = null;
          updateFormThreadId(null);
          messagesContainer.innerHTML = "";
          // Add placeholder message for new chat
          const now = new Date();
          const timeStr = now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0");
          const placeholderEl = document.createElement("div");
          placeholderEl.className = "flex items-start gap-2.5";
          placeholderEl.setAttribute("data-placeholder", "true");
          placeholderEl.innerHTML = `
            <div class="flex flex-col w-full">
              <div class="flex items-center space-x-2">
                <span class="text-sm font-semibold text-heading">Assistant</span>
                <span class="text-sm text-body">${timeStr}</span>
              </div>
              <p class="text-sm text-body mt-2">What's on the agenda today?</p>
            </div>
          `;
          messagesContainer.appendChild(placeholderEl);
          const connectionStatus = document.getElementById("connection-status");
          if (connectionStatus) connectionStatus.style.display = "none";
          if (input) input.disabled = false;
          if (button) button.disabled = false;
          if (modelSelect) modelSelect.disabled = false;
          updateSidebarActiveState(null);
        }
      });

      // Handle thread switching via sidebar clicks
      const sidebarLinks = document.querySelectorAll('[data-thread-id]');
      sidebarLinks.forEach(function (link) {
        link.addEventListener("click", function (e) {
          const newThreadId = this.dataset.threadId;
          if (newThreadId && newThreadId !== activeThreadId) {
            e.preventDefault(); // Prevent default navigation
            switchThread(newThreadId);
            
            // Optionally: Load messages for new thread via AJAX
            // For now, user can refresh if they want to see old messages
            // In the future, we'd fetch messages via API and update DOM
          }
        });
      });
      
      // Initialize sidebar accessibility fixes
      setupSidebarAccessibility();
    })();
  </script>
  </main>
</div>
{% endblock content %}
